import{j as k}from"./jsx-runtime-BjG_zV1W.js";import{h as G,i as $,t as U}from"./polymorphic-factory-CBTtpKIs.js";import{r as g}from"./chunk-XJI4KG32-BUsIIvMu.js";import{T as J}from"./Text-CJ3mMfZs.js";import{I as W,g as X,R as Y,b as q}from"./context-BUMALDVt.js";var P={root:"m_849cf0da"};const B={underline:"hover"},_=G((e,s)=>{const{underline:n,className:o,unstyled:r,mod:t,...c}=$("Anchor",B,e);return k.jsx(J,{component:"a",ref:s,className:U({[P.root]:!r},o),...c,mod:[{underline:n},t],__staticSelector:"Anchor",unstyled:r})});_.classes=P;_.displayName="@mantine/core/Anchor";const D=(e,s,n,o)=>{var t,c,h,N;const r=[n,{code:s,...o||{}}];if((c=(t=e==null?void 0:e.services)==null?void 0:t.logger)!=null&&c.forward)return e.services.logger.forward(r,"warn","react-i18next::",!0);p(r[0])&&(r[0]=`react-i18next:: ${r[0]}`),(N=(h=e==null?void 0:e.services)==null?void 0:h.logger)!=null&&N.warn?e.services.logger.warn(...r):console!=null&&console.warn&&console.warn(...r)},L={},E=(e,s,n,o)=>{p(n)&&L[n]||(p(n)&&(L[n]=new Date),D(e,s,n,o))},j=(e,s)=>()=>{if(e.isInitialized)s();else{const n=()=>{setTimeout(()=>{e.off("initialized",n)},0),s()};e.on("initialized",n)}},S=(e,s,n)=>{e.loadNamespaces(s,j(e,n))},O=(e,s,n,o)=>{if(p(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(s)>-1)return S(e,n,o);n.forEach(r=>{e.options.ns.indexOf(r)<0&&e.options.ns.push(r)}),e.loadLanguages(s,j(e,o))},H=(e,s,n={})=>!s.languages||!s.languages.length?(E(s,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:s.languages}),!0):s.hasLoadedNamespace(e,{lng:n.lng,precheck:(o,r)=>{var t;if(((t=n.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&o.services.backendConnector.backend&&o.isLanguageChangingTo&&!r(o.isLanguageChangingTo,e))return!1}}),p=e=>typeof e=="string",K=e=>typeof e=="object"&&e!==null,Q=(e,s)=>{const n=g.useRef();return g.useEffect(()=>{n.current=e},[e,s]),n.current},F=(e,s,n,o)=>e.getFixedT(s,n,o),Z=(e,s,n,o)=>g.useCallback(F(e,s,n,o),[e,s,n,o]),oe=(e,s={})=>{var R,v,I,z;const{i18n:n}=s,{i18n:o,defaultNS:r}=g.useContext(W)||{},t=n||o||X();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new Y),!t){E(t,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(u,f)=>p(f)?f:K(f)&&p(f.defaultValue)?f.defaultValue:Array.isArray(u)?u[u.length-1]:u,l=[i,{},!1];return l.t=i,l.i18n={},l.ready=!1,l}(R=t.options.react)!=null&&R.wait&&E(t,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const c={...q(),...t.options.react,...s},{useSuspense:h,keyPrefix:N}=c;let a=r||((v=t.options)==null?void 0:v.defaultNS);a=p(a)?[a]:a||["translation"],(z=(I=t.reportNamespaces).addUsedNamespaces)==null||z.call(I,a);const d=(t.isInitialized||t.initializedStoreOnce)&&a.every(i=>H(i,t,c)),M=Z(t,s.lng||null,c.nsMode==="fallback"?a:a[0],N),C=()=>M,x=()=>F(t,s.lng||null,c.nsMode==="fallback"?a:a[0],N),[A,w]=g.useState(C);let y=a.join();s.lng&&(y=`${s.lng}${y}`);const b=Q(y),m=g.useRef(!0);g.useEffect(()=>{const{bindI18n:i,bindI18nStore:l}=c;m.current=!0,!d&&!h&&(s.lng?O(t,s.lng,a,()=>{m.current&&w(x)}):S(t,a,()=>{m.current&&w(x)})),d&&b&&b!==y&&m.current&&w(x);const u=()=>{m.current&&w(x)};return i&&(t==null||t.on(i,u)),l&&(t==null||t.store.on(l,u)),()=>{m.current=!1,t&&(i==null||i.split(" ").forEach(f=>t.off(f,u))),l&&t&&l.split(" ").forEach(f=>t.store.off(f,u))}},[t,y]),g.useEffect(()=>{m.current&&d&&w(C)},[t,N,d]);const T=[A,t,d];if(T.t=A,T.i18n=t,T.ready=d,d||!d&&!h)return T;throw new Promise(i=>{s.lng?O(t,s.lng,a,()=>i()):S(t,a,()=>i())})};export{_ as A,oe as u};
