import{r as g}from"./chunk-GNGMS2XR-D0nGIQkJ.js";import{I as _,g as j,R as k,b as G}from"./context-Gfht7yEU.js";const $=(e,n,s,a)=>{var t,f,T,w;const o=[s,{code:n,...a||{}}];if((f=(t=e==null?void 0:e.services)==null?void 0:t.logger)!=null&&f.forward)return e.services.logger.forward(o,"warn","react-i18next::",!0);m(o[0])&&(o[0]=`react-i18next:: ${o[0]}`),(w=(T=e==null?void 0:e.services)==null?void 0:T.logger)!=null&&w.warn?e.services.logger.warn(...o):console!=null&&console.warn&&console.warn(...o)},O={},E=(e,n,s,a)=>{m(s)&&O[s]||(m(s)&&(O[s]=new Date),$(e,n,s,a))},P=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},S=(e,n,s)=>{e.loadNamespaces(n,P(e,s))},A=(e,n,s,a)=>{if(m(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return S(e,s,a);s.forEach(o=>{e.options.ns.indexOf(o)<0&&e.options.ns.push(o)}),e.loadLanguages(n,P(e,a))},U=(e,n,s={})=>!n.languages||!n.languages.length?(E(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0):n.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,o)=>{var t;if(((t=s.bindI18n)==null?void 0:t.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!o(a.isLanguageChangingTo,e))return!1}}),m=e=>typeof e=="string",J=e=>typeof e=="object"&&e!==null,W=(e,n)=>{const s=g.useRef();return g.useEffect(()=>{s.current=e},[e,n]),s.current},F=(e,n,s,a)=>e.getFixedT(n,s,a),X=(e,n,s,a)=>g.useCallback(F(e,n,s,a),[e,n,s,a]),B=(e,n={})=>{var R,v,z,L;const{i18n:s}=n,{i18n:a,defaultNS:o}=g.useContext(_)||{},t=s||a||j();if(t&&!t.reportNamespaces&&(t.reportNamespaces=new k),!t){E(t,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const i=(l,u)=>m(u)?u:J(u)&&m(u.defaultValue)?u.defaultValue:Array.isArray(l)?l[l.length-1]:l,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}(R=t.options.react)!=null&&R.wait&&E(t,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const f={...G(),...t.options.react,...n},{useSuspense:T,keyPrefix:w}=f;let r=o||((v=t.options)==null?void 0:v.defaultNS);r=m(r)?[r]:r||["translation"],(L=(z=t.reportNamespaces).addUsedNamespaces)==null||L.call(z,r);const d=(t.isInitialized||t.initializedStoreOnce)&&r.every(i=>U(i,t,f)),M=X(t,n.lng||null,f.nsMode==="fallback"?r:r[0],w),C=()=>M,x=()=>F(t,n.lng||null,f.nsMode==="fallback"?r:r[0],w),[b,p]=g.useState(C);let y=r.join();n.lng&&(y=`${n.lng}${y}`);const I=W(y),N=g.useRef(!0);g.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=f;N.current=!0,!d&&!T&&(n.lng?A(t,n.lng,r,()=>{N.current&&p(x)}):S(t,r,()=>{N.current&&p(x)})),d&&I&&I!==y&&N.current&&p(x);const l=()=>{N.current&&p(x)};return i&&(t==null||t.on(i,l)),c&&(t==null||t.store.on(c,l)),()=>{N.current=!1,t&&(i==null||i.split(" ").forEach(u=>t.off(u,l))),c&&t&&c.split(" ").forEach(u=>t.store.off(u,l))}},[t,y]),g.useEffect(()=>{N.current&&d&&p(C)},[t,w,d]);const h=[b,t,d];if(h.t=b,h.i18n=t,h.ready=d,d||!d&&!T)return h;throw new Promise(i=>{n.lng?A(t,n.lng,r,()=>i()):S(t,r,()=>i())})};export{B as u};
